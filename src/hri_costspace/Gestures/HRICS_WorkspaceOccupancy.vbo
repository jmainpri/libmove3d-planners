#define GL_GLEXT_PROTOTYPES
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>
#include <GL/glext.h>

#include "HRICS_WorkspaceOccupancy.hpp"

#include "gridsAPI.hpp"

//#include <PolyVoxCore/SurfaceMesh.h>
//#include <PolyVoxCore/CubicSurfaceExtractorWithNormals.h>
//#include <PolyVoxCore/MarchingCubesSurfaceExtractor.h>
//#include <PolyVoxCore/SurfaceMesh.h>
//#include <PolyVoxCore/SimpleVolume.h>

using namespace std;
MOVE3D_USING_SHARED_PTR_NAMESPACE
using namespace HRICS;

// import most common Eigen types
// USING_PART_OF_NAMESPACE_EIGEN
using namespace Eigen;

HRICS::WorkspaceOccupancyGrid* global_workspaceGrid = NULL;

WorkspaceOccupancyCell::WorkspaceOccupancyCell()
{
  
}

WorkspaceOccupancyCell::WorkspaceOccupancyCell(int i, Vector3i coord , Vector3d corner, WorkspaceOccupancyGrid* grid) :
API::ThreeDCell(i,corner,grid)
{
  
}


WorkspaceOccupancyCell::~WorkspaceOccupancyCell()
{
  
}

void WorkspaceOccupancyCell::draw()
{
  //    double Cost = 0.0;
  double diagonal = 0.07;
  double colorvector[4];
  
  colorvector[0] = 0.0;       //red
  colorvector[1] = 0.0;       //green
  colorvector[2] = 0.0;       //blue
  colorvector[3] = 0.01;       //transparency
  
  
  Vector3d center = getCenter();
  
  g3d_set_color(Any,colorvector);
  g3d_draw_solid_sphere(center[0], center[1], center[2], diagonal, 10);
}

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
WorkspaceOccupancyGrid::WorkspaceOccupancyGrid(double pace, vector<double> envSize) :
API::ThreeDGrid( pace ,envSize ), m_drawing(false)
{
  cout << "AgentGrid::createAllCells" << endl;
  createAllCells();
}

//! @brief Virtual function that creates a new cell
//! @param integer index
//! @param integer x position in the grid
//! @param integer y position in the grid
//! @param integer z position in the grid
API::ThreeDCell* WorkspaceOccupancyGrid::createNewCell(unsigned int index,unsigned  int x,unsigned  int y,unsigned  int z )
{
  Vector3i pos;
  pos[0] = x; pos[1] = y; pos[2] = z;
  
  if ( index == 0 )
  {
    return new WorkspaceOccupancyCell( 0, pos ,_originCorner , this );
  }
  return new WorkspaceOccupancyCell( index, pos , computeCellCorner(x,y,z) , this );
}

WorkspaceOccupancyGrid::~WorkspaceOccupancyGrid()
{
  
}

void WorkspaceOccupancyGrid::init_drawing()
{
  // Initialise VBO - do only once, at start of program
  vector<GLfloat> grid_cells(24*_cells.size());

  // Verticies struct for each cell
  vector<Eigen::Vector3d> verticies(8);

  // Indice struct for each vertex
  m_indices.resize(36*_cells.size());

  cout << "36*_cells.size() : " << 36*_cells.size() << endl;
  
  for( int i=0; i<int(_cells.size()); i++)
  {
    dynamic_cast<API::ThreeDCell*>(_cells[i])->getVerticies(verticies);
    
    // 8*3 = 24; 7*3+2 = 23;
    
    for( int j=0; j<int(verticies.size()); j++)
    {
      grid_cells[24*i+j*3+0] = verticies[j][0];
      grid_cells[24*i+j*3+1] = verticies[j][1];
      grid_cells[24*i+j*3+2] = verticies[j][2]; 
    }

    //     V1 -- V0
    //    /      / |     Z  Y
    //   V2 -- V3 V5     |/
    //   |      | /       -- X
    //   V7 -- V4
    //

    // clockwise
    // 7 - 2 - 3 | 3 - 4 - 7 | 4 - 3 - 0 | 0 - 5 - 4
    // 1 - 0 - 3 | 3 - 2 - 1 | 6 - 7 - 4 | 4 - 5 - 6
    // 1 - 2 - 7 | 7 - 6 - 1 | 0 - 1 - 6 | 5 - 0 - 6

    m_indices[36*i+0] = 8*i+7; m_indices[36*i+1] = 8*i+2; m_indices[36*i+2] = 8*i+3;
    m_indices[36*i+3] = 8*i+3; m_indices[36*i+4] = 8*i+4; m_indices[36*i+5] = 8*i+7;
    m_indices[36*i+6] = 8*i+4; m_indices[36*i+7] = 8*i+3; m_indices[36*i+8] = 8*i+0;
    m_indices[36*i+9] = 8*i+0; m_indices[36*i+10] = 8*i+5; m_indices[36*i+11] = 8*i+4;

    m_indices[36*i+12] = 8*i+1; m_indices[36*i+13] = 8*i+0; m_indices[36*i+14] = 8*i+3;
    m_indices[36*i+15] = 8*i+3; m_indices[36*i+16] = 8*i+2; m_indices[36*i+17] = 8*i+1;
    m_indices[36*i+18] = 8*i+6; m_indices[36*i+19] = 8*i+7; m_indices[36*i+20] = 8*i+4;
    m_indices[36*i+21] = 8*i+4; m_indices[36*i+22] = 8*i+5; m_indices[36*i+23] = 8*i+6;

    m_indices[36*i+24] = 8*i+1; m_indices[36*i+25] = 8*i+2; m_indices[36*i+26] = 8*i+7;
    m_indices[36*i+27] = 8*i+7; m_indices[36*i+28] = 8*i+6; m_indices[36*i+29] = 8*i+1;
    m_indices[36*i+30] = 8*i+0; m_indices[36*i+31] = 8*i+1; m_indices[36*i+32] = 8*i+6;
    m_indices[36*i+33] = 8*i+5; m_indices[36*i+34] = 8*i+0; m_indices[36*i+35] = 8*i+6;

//    cout << "36*i+35 : " << 36*i+35 << endl;
  }
  
  //    Vertices of a triangle (counter-clockwise winding)
  //    float data[] = {1.0, 0.0, 1.0, 0.0, 0.0, -1.0, -1.0, 0.0, 1.0};
  //    cout << "data size : " << sizeof(data) << endl;
  
  // Create a new VBO and use the variable id to store the VBO id
  // Make the new VBO active
  // Upload vertex data to the video device
  glGenBuffers( 1, &m_trianglebuffer );
  glBindBuffer( GL_ARRAY_BUFFER, m_trianglebuffer );
  glBufferData( GL_ARRAY_BUFFER, 24*_cells.size()*sizeof(GLfloat), &grid_cells[0], GL_STATIC_DRAW );
  
  //Draw Triangle from VBO - do each time window, view point or data changes
  //Establish its 3 coordinates per vertex with zero stride in this array; necessary here
  glVertexPointer( 3, GL_FLOAT, 0, NULL );
  
  // Generate a buffer for the indices
//   glGenBuffers( 1, &m_elementbuffer );
//   glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, m_elementbuffer );
//   glBufferData( GL_ELEMENT_ARRAY_BUFFER, m_indices.size() * sizeof(GLubyte), &m_indices[0], GL_STATIC_DRAW );
}

void WorkspaceOccupancyGrid::draw()
{
  if(!m_drawing) {
    cout << "init drawing" << endl;
    init_drawing();
    m_drawing = true;
    cout << "draw !!!" << endl;
  }
  
  // Establish array contains vertices (not normals, colours, texture coords etc)
  glEnableClientState( GL_VERTEX_ARRAY );

  // Make the new VBO active. Repeat here incase changed since initialisation
  // Actually draw the triangle, giving the number of vertices provided
  glBindBuffer( GL_ARRAY_BUFFER, m_trianglebuffer );
  glVertexPointer( 3, GL_FLOAT, 0, NULL );
  glDrawArrays( GL_TRIANGLES, 0, 8*_cells.size() );

  // Draw the triangles with indices
  //glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, m_elementbuffer );
  //glDrawElements( GL_TRIANGLE_STRIP, _cells.size(), GL_UNSIGNED_BYTE, NULL );

  // Disables array contains vertices
  glDisableClientState( GL_VERTEX_ARRAY );

  // Force display to be drawn now
  glFlush();
}

void WorkspaceOccupancyGrid::setRegressedMotions(const std::vector<motion_t>& motions)
{
  m_motions = motions;
}

void WorkspaceOccupancyGrid::computeOccpancy()
{
  
}
